; Define pin connections for 74HC595
DATA_PIN	BIT	P3.4	; Data pin for 74HC595
CLOCK_PIN	BIT	P3.6	; Clock pin for 74HC595
LATCH_PIN	BIT	P3.5	; Latch pin for 74HC595

RDL	BIT	P1.6

BOARD_DATA_POINTER	SET	20H
SNAKE_DATA_POINTER	SET	37H	; 37H to 77H is all the board
SNAKE_DATA_LENGTH	SET	30H
SNAKE_LENGTH_TEMP	SET	31H
NEW_APPLE	SET	32H
CURRENT_NOTE_TH	SET	33H
CURRENT_NOTE_TL	SET	34H


MUTEX1	BIT	40H		; 28H first bit
MUTEX2	BIT	41H
DISPLAY_APPLE	BIT	42H
SNAKE_INC	BIT	43H

ROW_REGISTER	SET	R3
TICK_REGISTER	SET	R7

AX	SET	R2
AY	SET	R3
PX	SET	R4
PY	SET	R5
VX	SET	R6
VY	SET	R7

GAME_TICKS_PER_CYCLE	SET	20D	; each tick is 50ms
ONE_HOT_CODE_MAP	SET	0300H
BCD_MAP	SET	0310H


	ORG	0000H
	JMP	MAIN

	ORG	0003H
	JMP	INPUT_ISR_0

	ORG	000BH
	JMP	TIMER0_ISR

	ORG	0013H
	JMP	INPUT_ISR_1

	ORG	001BH
	JMP	TIMER1_ISR


TIMER0_ISR:
	MOV	TH0, #03CH
	MOV	TL0, #0AFH
	DJNZ	TICK_REGISTER, SKIP_TIMER0_ISR
	MOV	TICK_REGISTER, #GAME_TICKS_PER_CYCLE
	CALL	GAME_CYCLE
SKIP_TIMER0_ISR:
	RETI

TIMER1_ISR:
	RETI

INPUT_ISR_0:
	JB	MUTEX1, INPUT_ISR_0_DONE
	SETB	MUTEX1
;	CPL	P2.4
	PUSH	PSW
	SETB	RS0
	MOV	VX, #0H
	MOV	VY, #1H
	POP	PSW
INPUT_ISR_0_DONE:
	RETI

INPUT_ISR_1:
	JB	MUTEX2, INPUT_ISR_1_DONE
	SETB	MUTEX2
	PUSH	PSW
	SETB	RS0

	SETB	P1.0
	JB	RDL, RIGHT_ISR
	SETB	P1.1
	JB	RDL, DOWN_ISR
	SETB	P1.2
	JB	RDL, LEFT_ISR
	SJMP	INPUT_ISR_1_CLEANUP

LEFT_ISR:
	MOV	VX, #1H
	MOV	VY, #0H
;	CPL	P2.5
	SJMP	INPUT_ISR_1_CLEANUP
DOWN_ISR:
	MOV	VX, #0H
	MOV	VY, #0FFH
;	CPL	P2.6
	SJMP	INPUT_ISR_1_CLEANUP
RIGHT_ISR:
	MOV	VX, #0FFH
	MOV	VY, #0H
;	CPL	P2.7
	SJMP	INPUT_ISR_1_CLEANUP

INPUT_ISR_1_CLEANUP:
	CLR	P1.0
	CLR	P1.1
	CLR	P1.2
	POP	PSW
INPUT_ISR_1_DONE:
	RETI

GAME_CYCLE:
	PUSH	A
	PUSH	B
	PUSH	PSW
	SETB	RS0

	CALL	MOVE_PLAYER
	CALL	SHIFT_INTO_SNAKE
	CALL	CHECK_APPLE
	CALL	RESET_BOARD
	CALL	DRAW_BOARD

	POP	PSW
	POP	B
	POP	A
	RET

MOVE_PLAYER:
	XCH	A, PX
	ADD	A, VX
	CALL	MOD8
	XCH	A, PX

	XCH	A, PY
	ADD	A, VY
	CALL	MOD8
	XCH	A, PY

	RET

RESET_BOARD:
	MOV	20H, #0
	MOV	21H, #0
	MOV	22H, #0
	MOV	23H, #0
	MOV	24H, #0
	MOV	25H, #0
	MOV	26H, #0
	MOV	27H, #0
	RET

SHIFT_INTO_SNAKE:
	MOV	SNAKE_LENGTH_TEMP, SNAKE_DATA_LENGTH
	DEC	SNAKE_LENGTH_TEMP
SHIFT_INTO_SNAKE_LOOP:
	MOV	A, SNAKE_LENGTH_TEMP
	ADD	A, #SNAKE_DATA_POINTER
	MOV	R0, A
	MOV	R1, A
	DEC	R1
	MOV	A, @R1
	MOV	@R0, A
	DJNZ	SNAKE_LENGTH_TEMP, SHIFT_INTO_SNAKE_LOOP

	MOV	A, PY
	SWAP	A
	ORL	A, PX
	MOV	R0, #SNAKE_DATA_POINTER
	MOV	@R0, A

	RET

DRAW_BOARD:
	MOV	SNAKE_LENGTH_TEMP, SNAKE_DATA_LENGTH
	JNB	SNAKE_INC, DRAW_BOARD_LOOP
	DEC	SNAKE_LENGTH_TEMP
	CLR	SNAKE_INC
DRAW_BOARD_LOOP:
	MOV	R0, SNAKE_LENGTH_TEMP
	DEC	R0
	MOV	A, R0
	ADD	A, #SNAKE_DATA_POINTER
	MOV	R0, A
	MOV	A, @R0
	MOV	R0, A

	ANL	A, #0FH
	ADD	A, #BOARD_DATA_POINTER
	MOV	R1, A
	MOV	B, @R1

	MOV	A, R0
	SWAP	A
	ANL	A, #0FH
	MOV	DPTR, #ONE_HOT_CODE_MAP
	MOVC	A, @A+DPTR
	ORL	A, B
	MOV	@R1, A

	DJNZ	SNAKE_LENGTH_TEMP, DRAW_BOARD_LOOP

	CPL	DISPLAY_APPLE
	JNB	DISPLAY_APPLE, DRAW_BOARD_DONE

	MOV	A, AX
	ADD	A, #BOARD_DATA_POINTER
	MOV	R1, A		; R1 = row pointer

	MOV	B, @R1		; Get existing row content

	MOV	A, AY
	MOV	DPTR, #0300H
	MOVC	A, @A+DPTR	; A = column bitmask

	ORL	A, B
	MOV	@R1, A		; Store updated row with apple bit added
DRAW_BOARD_DONE:
	RET

CHECK_APPLE:
	MOV	A, PX
	XRL	A, AX
	JNZ	CHECK_APPLE_DONE

	MOV	A, PY
	XRL	A, AY
	JNZ	CHECK_APPLE_DONE

	INC	SNAKE_DATA_LENGTH
	SETB	SNAKE_INC
	CALL	GENERATE_NEW_APPLE

CHECK_APPLE_DONE:
	RET

GENERATE_NEW_APPLE:
	MOV	A, TH0
	CALL	MOD8
	MOV	AX, A

	MOV	A, TL0
	CALL	MOD8
	MOV	AY, A

	MOV	A, AY
	SWAP	A
	ORL	A, AX
	MOV	NEW_APPLE, A

	MOV	B, SNAKE_DATA_LENGTH
	MOV	R0, #SNAKE_DATA_POINTER

CHECK_APPLE_COLLISION_LOOP:
	MOV	A, @R0
	CJNE	A, NEW_APPLE, NO_COLLISION
	SJMP	GENERATE_NEW_APPLE

NO_COLLISION:
	INC	R0
	DJNZ	B, CHECK_APPLE_COLLISION_LOOP

	RET




MAIN:
	MOV	SP, #10H
	CALL	SETUP

RENDER_LOOP:
	MOV	P0, #0FFH	; reset cathode
	CALL	RENDER_BOARD
	CALL	RENDER_SCORE
	CALL	ROTATE_CATHODE
	CLR	MUTEX1
	CLR	MUTEX2
	SJMP	RENDER_LOOP

SETUP:
	SETB	EA
	SETB	EX0
	SETB	IT0
	SETB	EX1
	SETB	IT1
	SETB	ET0

	MOV	IP, #00H
	MOV	TH0, #03CH
	MOV	TL0, #0AFH
	SETB	TR0
	MOV	ROW_REGISTER, #0H
	CLR	P1.0
	CLR	P1.1
	CLR	P1.2
	MOV	TICK_REGISTER, #20D
	MOV	SNAKE_DATA_LENGTH, #3

	SETB	RS0
	MOV	AX, #5
	MOV	AY, #5
	MOV	VX, #1H
	MOV	VY, #0H
	CLR	RS0

	RET

RENDER_BOARD:
	MOV	A, ROW_REGISTER
	ADD	A, #BOARD_DATA_POINTER
	MOV	R0, A
	MOV	A, @R0

	CALL	SEND_TO_595

	INC	ROW_REGISTER
	XCH	A, ROW_REGISTER
	CALL	MOD8
	XCH	A, ROW_REGISTER	; ROW_REGISTER = ROW_REGISTER + 1 MOD 8

	RET

MOD8:
	MOV	B, #8
	DIV	AB
	MOV	A, B
	RET

ROTATE_CATHODE:
	MOV	A, ROW_REGISTER
	MOV	R2, #0BFH
	XCH	A, R2
	INC	R2
ROTATE_CATHODE_LOOP:
	RL	A
	DJNZ	R2, ROTATE_CATHODE_LOOP

	MOV	P0, A
	CALL	DELAY2
	RET

RENDER_SCORE:
	PUSH	P0		; save cathode of led matrix

	MOV	A, SNAKE_DATA_LENGTH
	CLR	C
	SUBB	A, #3		; score = snake length - 3
	CALL	BIN2BCD		; R0 and R1 contain BCDs of score
	MOV	DPTR, #BCD_MAP
	MOV 	R1, A
	MOV 	R0, B



	MOV	P0, #0		; disable all segments
	MOV 	A, P2
	ANL 	A, #11100011B
	ORL 	A, #00000100B
	MOV	P2, A		; select the second seg group

	MOV 	A, R1
	MOVC	A, @A+DPTR	; map A to 7seg
	MOV	P0, A		; change 7seg

	MOV	P0, #0		; disable all segments
	MOV 	A, P2
	ANL 	A, #11100011B
	MOV	P2, A		; select the first seg group
	MOV	A, B
	MOVC	A, @A+DPTR
	MOV	P0, A
	MOV 	P0, #0

	MOV 	A, P2
	ORL 	A, #00011100B
	MOV	P2, A		; select the last segment (ignore)

	POP	P0		; revert cathode
	RET


; series to parallel to 8x8 led
SEND_TO_595:
	MOV	R6, #08H
SEND_LOOP:
	RLC	A
	NOP
	MOV	DATA_PIN, C
	SETB	CLOCK_PIN
	CALL	DELAY
	CLR	CLOCK_PIN
	CALL	DELAY
	DJNZ	R6, SEND_LOOP
	SETB	LATCH_PIN
	CALL	DELAY
	CLR	LATCH_PIN
	RET

; latch delay
DELAY:
	MOV	R5, #05H
	DJNZ	R5, $
	RET

; delay for the cathode resetting
DELAY2:
	MOV	R6, #04D
DEL1:	MOV	R5, #0250D
	DJNZ	R5, $
	DJNZ	R6, DEL1
	RET

BIN2BCD:
	MOV	B, #10D
	DIV	AB
	RET

	ORG	ONE_HOT_CODE_MAP
	DB	00000001B
	DB	00000010B
	DB	00000100B
	DB	00001000B
	DB	00010000B
	DB	00100000B
	DB	01000000B
	DB	10000000B
	DB	00000000B

	ORG	BCD_MAP
	DB	3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH
	END
