; 74hc595 shift register pins
DATA_PIN	BIT	P3.4	; serial data input
CLOCK_PIN	BIT	P3.6	; shift register clock input
LATCH_PIN	BIT	P3.5	; storage register clock input

; other I/O pins
RDL	BIT	P1.6		; right, down, left input
BUZZ_PIN	BIT	P2.5	; buzzer output

; static variables
BOARD_DATA_POINTER	SET	20H
SNAKE_DATA_POINTER	SET	38H	; snake occupies 37Hâ€“77H
SNAKE_DATA_LENGTH	SET	30H
SNAKE_LENGTH_TEMP	SET	31H

; music playback registers
NOTE_INDEX	SET	32H
NOTE_H	SET	33H
NOTE_L	SET	34H
DURATION_INDEX	SET	35H
DURATION_REGISTER	SET	36H
P2_SHADOW	SET	37H	; used to avoid conflicts with render_score

; static flags (all in register 28H)
DISPLAY_APPLE	BIT	40H
SNAKE_INC	BIT	41H
SHOULD_REST	BIT	42H

ROW_REGISTER	SET	R3	; used to rotate the cathode
TICK_REGISTER	SET	R7	; used to control cycle rate

; bank 1 (gameplay logic)
AX	SET	R2		; apple x position
AY	SET	R3		; apple y position
PX	SET	R4		; snake head x position
PY	SET	R5		; snake head y position
VX	SET	R6		; snake x velocity
VY	SET	R7		; snake y velocity

; constants
TICKS_PER_GAME_CYCLE	SET	10D	; game loop cycle duration (in ticks)
ONE_HOT_CODE_MAP	SET	0300H	; one-hot display encoding
BCD_MAP	SET	0310H		; binary-coded decimal map
NOTES_MAP	SET	0320H	; melody notes
DURATIONS_MAP	SET	03D6H	; note durations
NOTES_MAP_LENGTH	SET	182D	; length of melody 


	ORG	0000H
	JMP	MAIN

; IVT mapping
	ORG	0003H
	JMP	INPUT_ISR_0
	ORG	000BH
	JMP	TIMER0_ISR
	ORG	0013H
	JMP	INPUT_ISR_1
	ORG	001BH
	JMP	TIMER1_ISR

TIMER0_ISR:
	CALL	PLAY_MUSIC	; call the music manager every tick
	DJNZ	TICK_REGISTER, SKIP_TIMER0_ISR	; wait to 
	MOV	TICK_REGISTER, #TICKS_PER_GAME_CYCLE
	CALL	GAME_CYCLE
SKIP_TIMER0_ISR:
	CALL	START_TIMER0	; restart timer
	RETI

START_TIMER0:
	MOV	TH0, #0C5H	; 15ms
	MOV	TL0, #068H
	SETB	TR0
	RET

TIMER1_ISR:
	JB	SHOULD_REST, TIMER1_ISR_REST ; if rest: skip
	CPL	BUZZ_PIN ; oscillate the buzzer
	SJMP 	TIMER1_ISR_DONE

TIMER1_ISR_REST:
	SETB BUZZ_PIN ; mostly for aesthetic

TIMER1_ISR_DONE:
;	CALL START_TIMER1 ; idk, but the led matrix glithes if I call start timer1
	MOV	TH1, NOTE_H ; set preload of note freq
	MOV	TL1, NOTE_L
	SETB	TR1 ; enable timer
	MOV	P2_SHADOW, P2 ; shadow copy of P2
	RETI

START_TIMER1:
	MOV	TH1, NOTE_H ; set preload of note freq
	MOV	TL1, NOTE_L
	SETB	TR1 ; enable timer
	RET

INPUT_ISR_0:
	PUSH	PSW ; save context
	SETB	RS0 ; switch to bank 1
	MOV	VX, #0H
	MOV	VY, #1H ; change direction to UP

	MOV A, P2
	RRC A
	MOV P2, A

	POP	PSW ; restore context
INPUT_ISR_0_DONE:
	RETI

INPUT_ISR_1:
	PUSH	PSW ; save context
	SETB	RS0 ; switch to bank 1

	MOV A, P2
	RRC A
	MOV P2, A

	SETB	P1.0 ; check if RIGHT
	JB	RDL, RIGHT_ISR
	SETB	P1.1 ; check if DOWN
	JB	RDL, DOWN_ISR
	SETB	P1.2 ; check if LEFT
	JB	RDL, LEFT_ISR
	SJMP	INPUT_ISR_1_CLEANUP ; default

LEFT_ISR:
	MOV	VX, #0FFH ; -1 in 2's complement
	MOV	VY, #0H ; change direction to LEFT
	SJMP	INPUT_ISR_1_CLEANUP
DOWN_ISR:
	MOV	VX, #0H	 ; change direction to DOWN
	MOV	VY, #0FFH ; -1 in 2's complement
	SJMP	INPUT_ISR_1_CLEANUP
RIGHT_ISR:
	MOV	VX, #1H
	MOV	VY, #0H ; change direction to RIGHT
	SJMP	INPUT_ISR_1_CLEANUP

INPUT_ISR_1_CLEANUP:
	CLR	P1.0
	CLR	P1.1
	CLR	P1.2
	POP	PSW
INPUT_ISR_1_DONE:
	SETB INT1
	RETI

GAME_CYCLE:
	; save context
	PUSH	A
	PUSH	B
	PUSH	PSW

	SETB	RS0 ; use bank 1

	CALL	MOVE_PLAYER
	CALL	SHIFT_INTO_SNAKE
	CALL	CHECK_APPLE
	CALL	RESET_BOARD
	CALL	DRAW_BOARD

	; restore context
	POP	PSW
	POP	B
	POP	A

	RET

MOVE_PLAYER:
	; PX += VX
	XCH	A, PX
	ADD	A, VX
	CALL	MOD8
	XCH	A, PX

	; PY += VY
	XCH	A, PY
	ADD	A, VY
	CALL	MOD8
	XCH	A, PY

	RET

RESET_BOARD:
	MOV	20H, #0
	MOV	21H, #0
	MOV	22H, #0
	MOV	23H, #0
	MOV	24H, #0
	MOV	25H, #0
	MOV	26H, #0
	MOV	27H, #0
	RET

; insert PX, PY into the beginning of the snake array
SHIFT_INTO_SNAKE:
	MOV	SNAKE_LENGTH_TEMP, SNAKE_DATA_LENGTH
	DEC	SNAKE_LENGTH_TEMP
SHIFT_INTO_SNAKE_LOOP:
	MOV	A, SNAKE_LENGTH_TEMP
	ADD	A, #SNAKE_DATA_POINTER
	MOV	R0, A
	MOV	R1, A
	DEC	R1
	MOV	A, @R1
	MOV	@R0, A
	DJNZ	SNAKE_LENGTH_TEMP, SHIFT_INTO_SNAKE_LOOP

	MOV	A, PY
	SWAP	A
	ORL	A, PX
	MOV	R0, #SNAKE_DATA_POINTER
	MOV	@R0, A

	RET

DRAW_BOARD:
	MOV	SNAKE_LENGTH_TEMP, SNAKE_DATA_LENGTH
	JNB	SNAKE_INC, DRAW_BOARD_LOOP ; the flag indicates not to draw the last cell for one cycle
	DEC	SNAKE_LENGTH_TEMP
	CLR	SNAKE_INC
DRAW_BOARD_LOOP:
	; draw snake cells
	MOV	R0, SNAKE_LENGTH_TEMP
	DEC	R0
	MOV	A, R0
	ADD	A, #SNAKE_DATA_POINTER
	MOV	R0, A
	MOV	A, @R0
	MOV	R0, A

	ANL	A, #0FH
	ADD	A, #BOARD_DATA_POINTER
	MOV	R1, A
	MOV	B, @R1

	MOV	A, R0
	SWAP	A
	ANL	A, #0FH
	MOV	DPTR, #ONE_HOT_CODE_MAP
	MOVC	A, @A+DPTR
	ORL	A, B
	MOV	@R1, A

	DJNZ	SNAKE_LENGTH_TEMP, DRAW_BOARD_LOOP

	CPL	DISPLAY_APPLE ; blinking effect
	JNB	DISPLAY_APPLE, DRAW_BOARD_DONE

	MOV	A, AX
	ADD	A, #BOARD_DATA_POINTER
	MOV	R1, A		; R1 = row pointer

	MOV	B, @R1		; get existing row content

	MOV	A, AY
	MOV	DPTR, #0300H
	MOVC	A, @A+DPTR	; A = column bitmask

	ORL	A, B
	MOV	@R1, A		; store updated row with apple bit added
DRAW_BOARD_DONE:
	RET

CHECK_APPLE:
	MOV	A, PX
	XRL	A, AX
	JNZ	CHECK_APPLE_DONE ; if PX != AX, skip

	MOV	A, PY
	XRL	A, AY
	JNZ	CHECK_APPLE_DONE ; if PY != AY, skip

	; match
	INC	SNAKE_DATA_LENGTH
	SETB	SNAKE_INC ; don't draw last cell
	CALL	GENERATE_NEW_APPLE

CHECK_APPLE_DONE:
	RET

GENERATE_NEW_APPLE:
	MOV	A, TL0 ; pseudo RNG
	CALL	MOD8
	MOV	AX, A

	MOV	A, TL1
	CALL	MOD8
	MOV	AY, A

	; combine AX, AY
	MOV	A, AY
	SWAP	A
	ORL	A, AX
	MOV	R1, A

	MOV	B, SNAKE_DATA_LENGTH
	MOV	R0, #SNAKE_DATA_POINTER

CHECK_APPLE_COLLISION_LOOP:
	MOV	A, @R0
	XRL	A, R1
	JZ	GENERATE_NEW_APPLE
	INC	R0
	DJNZ	B, CHECK_APPLE_COLLISION_LOOP

	RET

PLAY_MUSIC:
	DJNZ	DURATION_REGISTER, PLAY_MUSIC_DONE ; skip if duration didn't finish
	PUSH	A ; save context
	PUSH	B

PLAY_MUSIC_REPEAT:
	; if we were resting, we have finished resting; otherwise, now rest
	CPL	SHOULD_REST

	JB	SHOULD_REST, SKIP_NEXT_NOTE
	CALL	NEXT_NOTE
SKIP_NEXT_NOTE:
	CALL	NEXT_DURATION
	INC	DURATION_REGISTER
	DJNZ	DURATION_REGISTER, PLAY_MUSIC_CLEAR ; don't want to use CJNE
	SJMP	PLAY_MUSIC_REPEAT	; skip 0 duration (usually happens with rests)
PLAY_MUSIC_CLEAR:
	POP	B ; restore context
	POP	A
PLAY_MUSIC_DONE:
	RET

NEXT_NOTE:
	MOV	DPTR, #NOTES_MAP

	MOV	A, NOTE_INDEX
	MOVC	A, @A+DPTR
	MOV	NOTE_H, A

	INC	NOTE_INDEX
	MOV	A, NOTE_INDEX
	MOVC	A, @A+DPTR
	MOV	NOTE_L, A

	INC	NOTE_INDEX
	MOV	A, NOTE_INDEX
	MOV	B, #NOTES_MAP_LENGTH
	DIV	AB
	MOV	NOTE_INDEX, B

	RET

NEXT_DURATION:
	MOV	DPTR, #DURATIONS_MAP
	MOV	A, DURATION_INDEX
	MOVC	A, @A+DPTR
	MOV	DURATION_REGISTER, A

	INC	DURATION_INDEX
	MOV	A, DURATION_INDEX
	MOV	B, #NOTES_MAP_LENGTH
	DIV	AB
	MOV	DURATION_INDEX, B

	RET


MAIN:
	MOV	SP, #10H ; shift the SP to allow use of bank 1 registers
	CALL	SETUP

RENDER_LOOP:
	MOV	P0, #0FFH ; reset cathode
	CALL	RENDER_BOARD
	CALL	ROTATE_CATHODE
	CALL	RENDER_SCORE
	SJMP	RENDER_LOOP

SETUP:
	MOV	TMOD, #11H ;setup timers
	MOV 	IE, #0FFH ; enable interrupts
	SETB	IT0 ; falling edge for external interrupts
	SETB	IT1
	SETB	PT1 ; priority to notes player

	; initialize values
	MOV 	P1, #0F8H
	MOV	TICK_REGISTER, #TICKS_PER_GAME_CYCLE
	MOV	SNAKE_DATA_LENGTH, #3H

	SETB	RS0
	MOV	AX, #4H
	MOV	AY, #4D
	MOV	VX, #1H
	MOV	VY, #0H
	CLR	RS0

	MOV	P2_SHADOW, #0FFH
	CALL	NEXT_NOTE
	CALL	NEXT_DURATION
	CALL	START_TIMER0
	CALL	START_TIMER1

	RET

RENDER_BOARD:
	MOV	A, ROW_REGISTER
	ADD	A, #BOARD_DATA_POINTER
	MOV	R0, A
	MOV	A, @R0

	CALL	SEND_TO_595

	INC	ROW_REGISTER
	XCH	A, ROW_REGISTER
	CALL	MOD8
	XCH	A, ROW_REGISTER	; ROW_REGISTER = (ROW_REGISTER + 1) MOD 8

	RET

ROTATE_CATHODE:
	MOV	A, ROW_REGISTER
	MOV	R2, #0FBH
	XCH	A, R2
	INC	R2
ROTATE_CATHODE_LOOP:
	RR	A
	DJNZ	R2, ROTATE_CATHODE_LOOP

	MOV	P0, A
	CALL	CATHODE_DELAY
	RET

RENDER_SCORE:
	PUSH	P0		; save cathode of led matrix

	MOV	A, SNAKE_DATA_LENGTH
	CLR	C
	SUBB	A, #3		; score = snake length - 3
	CALL	BIN2BCD		; R0 and R1 contain BCDs of score
	MOV	DPTR, #BCD_MAP
	MOV	R1, A
	MOV	R0, B

	MOV	A, P2_SHADOW 	; reading from P2 directly causes issues, so we use a shadow copy
	ORL	A, #00011100B
	MOV	P2, A		; select the last segment (ignore)

	MOV	A, R1
	MOVC	A, @A+DPTR	; map A to 7seg
	MOV	P0, A		; change 7seg

	MOV	A, P2_SHADOW
	ANL	A, #11100011B
	ORL	A, #00000100B
	MOV	P2, A		; select the second seg group

	MOV	A, P2_SHADOW
	ORL	A, #00011100B
	MOV	P2, A		; select the last segment (ignore)

	MOV	A, B
	MOVC	A, @A+DPTR
	MOV	P0, A

	MOV	A, P2_SHADOW
	ANL	A, #11100011B
	MOV	P2, A		; select the first seg group


	MOV	A, P2_SHADOW
	ORL	A, #00011100B
	MOV	P2, A		; select the last segment (ignore)

	POP	P0		; revert cathode
	RET


; series to parallel to 8x8 led
SEND_TO_595:

	MOV	R6, #08H
SEND_LOOP:
	RLC	A
	NOP
	MOV	DATA_PIN, C
	SETB	CLOCK_PIN
	NOP
	CLR	CLOCK_PIN
	NOP
	DJNZ	R6, SEND_LOOP
	SETB	LATCH_PIN
	NOP
	CLR	LATCH_PIN
	RET

CATHODE_DELAY:
	MOV	R6, #04D
DEL:	MOV	R5, #0250D
	DJNZ	R5, $
	DJNZ	R6, DEL
	RET

MOD8:
	MOV	B, #8
	DIV	AB
	MOV	A, B
	RET

BIN2BCD:
	MOV	B, #10D
	DIV	AB
	RET

	ORG	ONE_HOT_CODE_MAP
	DB	01H, 02H, 04H, 08H, 010H, 020H, 040H, 080H, 0H
	ORG	BCD_MAP
	DB	3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH

	ORG	NOTES_MAP
	DB	0F6H, 095H
	DB	0EDH, 02AH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F1H, 0E4H
	DB	0F1H, 00DH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0EDH, 02AH
	DB	0F6H, 095H
	DB	0EDH, 02AH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F1H, 0E4H
	DB	0F1H, 00DH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0F1H, 0E4H
	DB	0F6H, 095H
	DB	0EDH, 02AH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F1H, 0E4H
	DB	0F1H, 00DH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0EDH, 02AH
	DB	0F6H, 095H
	DB	0EDH, 02AH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F1H, 0E4H
	DB	0F1H, 00DH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH
	DB	0F1H, 0E4H
	DB	0F6H, 095H
	DB	0F6H, 095H
	DB	0F6H, 095H
	DB	0F6H, 095H
	DB	0F5H, 06EH
	DB	0F4H, 0CDH
	DB	0F5H, 06EH
	DB	0F6H, 095H
	DB	0F8H, 086H
	DB	0F6H, 095H
	DB	0F6H, 095H
	DB	0F6H, 095H
	DB	0F6H, 095H
	DB	0F6H, 095H
	DB	0F5H, 06EH
	DB	0F4H, 0CDH
	DB	0F5H, 06EH
	DB	0F6H, 095H
	DB	0EFH, 038H
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F4H, 0CDH
	DB	0F4H, 0CDH
	DB	0F4H, 0CDH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F1H, 0E4H
	DB	0EFH, 038H
	DB	0F4H, 0CDH
	DB	0F4H, 0CDH
	DB	0F4H, 0CDH
	DB	0F4H, 0CDH
	DB	0F3H, 06EH
	DB	0F4H, 0CDH
	DB	0F6H, 095H
	DB	0F7H, 09CH
	DB	0F4H, 0CDH
	DB	0F1H, 0E4H
	DB	0F3H, 06EH

	ORG	DURATIONS_MAP
	DB	032H, 019H
	DB	00CH, 000H
	DB	00CH, 000H
	DB	006H, 013H
	DB	006H, 013H
	DB	006H, 000H
	DB	006H, 000H
	DB	006H, 006H
	DB	006H, 013H
	DB	026H, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	04BH, 019H
	DB	032H, 019H
	DB	00CH, 000H
	DB	00CH, 000H
	DB	006H, 013H
	DB	006H, 013H
	DB	006H, 000H
	DB	006H, 000H
	DB	006H, 006H
	DB	006H, 013H
	DB	026H, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	04BH, 019H
	DB	032H, 019H
	DB	00CH, 000H
	DB	00CH, 000H
	DB	006H, 013H
	DB	006H, 013H
	DB	006H, 000H
	DB	006H, 000H
	DB	006H, 006H
	DB	006H, 013H
	DB	026H, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	04BH, 019H
	DB	032H, 019H
	DB	00CH, 000H
	DB	00CH, 000H
	DB	006H, 013H
	DB	006H, 013H
	DB	006H, 000H
	DB	006H, 000H
	DB	006H, 006H
	DB	006H, 013H
	DB	026H, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	04BH, 019H
	DB	00CH, 00CH
	DB	00CH, 00DH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	019H, 000H
	DB	019H, 000H
	DB	019H, 000H
	DB	032H, 000H
	DB	032H, 000H
	DB	064H, 019H
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	019H, 000H
	DB	019H, 000H
	DB	019H, 000H
	DB	064H, 04BH
	DB	00CH, 000H
	DB	00CH, 000H
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	019H, 000H
	DB	019H, 000H
	DB	019H, 000H
	DB	00CH, 026H
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	00CH, 00CH
	DB	019H, 000H
	DB	019H, 000H
	DB	019H, 000H
	DB	019H, 000H
	DB	096H, 000H
	DB	019H, 000H
	DB	019H, 000H
	DB	096H, 020H
	END